"use strict";(self.webpackChunktypegraphql_relay_connections_docs=self.webpackChunktypegraphql_relay_connections_docs||[]).push([[671],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return y}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var p=r.createContext({}),l=function(e){var n=r.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=l(e.components);return r.createElement(p.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=l(t),y=o,h=d["".concat(p,".").concat(y)]||d[y]||u[y]||a;return t?r.createElement(h,i(i({ref:n},c),{},{components:t})):r.createElement(h,i({ref:n},c))}));function y(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=d;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=t[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9881:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return p},default:function(){return y},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return u}});var r=t(7462),o=t(3366),a=(t(7294),t(3905)),i=["components"],s={sidebar_position:1},p="Intro \ud83d\ude80",l={unversionedId:"intro",id:"intro",title:"Intro \ud83d\ude80",description:"This library provides a way to setup typings for TypeGraphQL with Relay Connection Types. Relay Connection Types are a great way to define pagination in an app. This libraries connection types follow the Relay Connection Type Server Standard. You may want to read up on relay if you're confused on what the benefits of relay connections to find out how exactly this library works. Particularly this library implements the second part of the standard, so it accomplishes: 2.) A description of how to page through connections, so you may want to check out the relevant section on connections in the relay GraphQL server standard.",source:"@site/docs/intro.md",sourceDirName:".",slug:"/intro",permalink:"/typegraphql-relay-connections/docs/intro",editUrl:"https://github.com/johnsonjo4531/typegraphql-relay-connections/docs/blog/docs/intro.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"EdgeType \ud83e\uddc0",permalink:"/typegraphql-relay-connections/docs/api/edge-type"}},c={},u=[{value:"Show Me Da Codez!! \ud83d\udcbb",id:"show-me-da-codez-",level:2},{value:"Peer Dependencies \ud83d\udd17",id:"peer-dependencies-",level:2},{value:"Background on TypeGraphQL \ud83d\ude0e",id:"background-on-typegraphql-",level:2},{value:"Introductory Example \ud83e\udd13",id:"introductory-example-",level:2}],d={toc:u};function y(e){var n=e.components,t=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"intro-"},"Intro \ud83d\ude80"),(0,a.kt)("p",null,"This library provides a way to setup typings for ",(0,a.kt)("a",{parentName:"p",href:"https://typegraphql.com/"},"TypeGraphQL")," with Relay Connection Types. Relay Connection Types are a great way to define pagination in an app. This libraries connection types follow the ",(0,a.kt)("a",{parentName:"p",href:"https://relay.dev/docs/guides/graphql-server-specification/"},"Relay Connection Type Server Standard"),". You may want to read up on relay if you're confused on what the benefits of relay connections to find out how exactly this library works. Particularly this library implements the second part of the standard, so it accomplishes: 2.) A description of how to page through connections, so you may want to check out the ",(0,a.kt)("a",{parentName:"p",href:"https://relay.dev/docs/guides/graphql-server-specification/#connections"},"relevant section on connections in the relay GraphQL server standard"),"."),(0,a.kt)("p",null,"Note that though pagination types and utils are in this repo, the implementation of the paging algorithms are up to the user this is on purpose and is meant to keep this library small and maintanable."),(0,a.kt)("h2",{id:"show-me-da-codez-"},"Show Me Da Codez!! \ud83d\udcbb"),(0,a.kt)("p",null,"The quickest possible example to show what this library does is the following. We create two GraphQL ObjectTypes using TypeGraphQL object types."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import {\n  Field,\n  ObjectType,\n} from "type-graphql";\nimport {\n  ConnectionType,\n  EdgeType\n} from "typegraphql-relay-connections";\n\n@ObjectType()\nclass Song {\n  @Field()\n  id!: string\n\n  @Field()\n  title!: string;\n}\n\n@ObjectType()\nexport class SongEdge extends EdgeType(Song) {}\n\n@ObjectType()\nexport class SongConnection extends ConnectionType({\n  edge: SongEdge,\n  node: Song,\n}) {}\n')),(0,a.kt)("p",null,"The last thing we can do with this library is ",(0,a.kt)("a",{parentName:"p",href:"./tutorials/custom-cursors"},"extend the built in Cursor")," like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'declare module "typegraphql-relay-connections" {\n  interface Cursor {\n    id: string;\n  }\n}\n')),(0,a.kt)("h2",{id:"peer-dependencies-"},"Peer Dependencies \ud83d\udd17"),(0,a.kt)("p",null,"All our peer dependencies are due to TypeGraphQL. Follow the setup section for ",(0,a.kt)("a",{parentName:"p",href:"https://typegraphql.com/"},"TypeGraphQL"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"yarn add graphql@15 reflect-metadata type-graphql\n")),(0,a.kt)("h2",{id:"background-on-typegraphql-"},"Background on TypeGraphQL \ud83d\ude0e"),(0,a.kt)("p",null,"The idea behind TypeGraphQL is you define your GraphQL types using TypeScript. TypeGraphQL follows a code first approach rather than the schema first approach. Since TypeGraphQL's code first approach is written in TypeScript this allows you to strongly type your GraphQL server."),(0,a.kt)("h2",{id:"introductory-example-"},"Introductory Example \ud83e\udd13"),(0,a.kt)("p",null,"See this intro example ",(0,a.kt)("a",{parentName:"p",href:"https://codesandbox.io/s/typegraphql-relay-connections-intro-example-66ec9o"},"on codesandbox")),(0,a.kt)("p",null,"We'll start with some imports for this (you can replace apollo-server with the graphql server you choose to use.):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import "reflect-metadata";\nimport { ApolloServer } from "apollo-server";\nimport {\n  Field,\n  ObjectType,\n  Args,\n  Query,\n  Resolver,\n  buildSchema\n} from "type-graphql";\nimport {\n  ForwardPaginationArgs,\n  ConnectionType,\n  EdgeType,\n  BackwardPaginationArgs\n} from "typegraphql-relay-connections";\n// you\'ll have to make this yourself for an example see the codesandbox\nimport * as controller from "./song.controller";\n')),(0,a.kt)("p",null,"First create an object-type through ",(0,a.kt)("a",{parentName:"p",href:"https://typegraphql.com/"},"type-graphql")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@ObjectType()\nclass Song {\n  @Field()\n  id!: string\n\n  @Field()\n  title!: string;\n}\n")),(0,a.kt)("p",null,"That last part was just TypeGraphQL, but next is where this library comes in. It helps you create the Edge and Connection ObjectTypes as well as a custom cursor. Both the ",(0,a.kt)("inlineCode",{parentName:"p"},"EdgeType")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ConnectionType")," functions come from this library."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'@ObjectType()\nexport class SongEdge extends EdgeType(Song) {}\n\n@ObjectType()\nexport class SongConnection extends ConnectionType({\n  edge: SongEdge,\n  node: Song,\n}) {}\n\n\ndeclare module "typegraphql-relay-connections" {\n  interface Cursor {\n    id: string;\n  }\n}\n')),(0,a.kt)("p",null,"The Rest is just more TypeGraphQL."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@Resolver(Song)\nexport class SongResolver {\n  @Query(() => SongConnection)\n  async songs(\n    @Args() forwardPaging: ForwardPaginationArgs<Cursor>,\n    @Args() backwardPaging: BackwardPaginationArgs<Cursor>\n  ): Promise<SongConnection> {\n    // implementation up to you!\n    return controller.getSongs({forwardPaging, backwardPaging});\n  }\n}\n\nconst PORT = 4000;\n\nasync function bootstrap() {\n  const schema = await buildSchema({\n    resolvers: [SongResolver]\n  });\n\n  // Create the GraphQL server\n  const server = new ApolloServer({\n    schema\n  });\n\n  // Start the server\n  const { url } = await server.listen(PORT);\n  console.log(`Server is running, GraphQL Playground available at ${url}`);\n}\n\nbootstrap();\n")))}y.isMDXComponent=!0}}]);